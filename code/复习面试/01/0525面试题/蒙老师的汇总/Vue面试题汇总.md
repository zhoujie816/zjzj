# Vue面试题

### 1：$set解决了什么问题。使用场景。

### 2：Vuex数据流

### 3：Vuex能不能直接修改state，为什么。

### 4：Vue2和Vue3的区别。

### 5：nextTick解决什么问题。

### 6：如何确认登录状态

### 7：如何管理权限

### 8：如何实现按钮的权限而不是页面权限

### 9：Vue3如何解决Vue2的set问题

### 10：虚拟节点

### 11：组件通信

### 12：Vue生命周期

### 13：Vue路由传参

### 14：如何封装vue插件

### 15：如何封装一个Vue组件

### 16：Vue中如何做网络请求

### 17：Vue常用指令

### 18：vue的计算属性和方法的区别

### 19：vue中数组响应式的方法

### 20：vue中组件缓存

### 21：watch和computed的区别

### 22：Vue和React的区别。

### 23：如何理解MVVM。

### 24：key有啥作用

### 25：vue初始化页面的闪动问题

### 26：SPA单页面应用的优缺点

### 27：Vue怎么缓存数据。

### 28：Vuex常用的选项属性

### 29：vue-router原理（最好说点源码过程）

### 30：子组件是如何触发父组件方法的。（子组件是如何通过$emit触发父组件方法的）

父组件通过引入赋值把自身方法赋值给子组件的$listeners属性。

子组件就是通过调用自身$listeners属性上的方法来调用父组件方法的。

### 31：父子组件钩子函数的触发顺序，为什么会这样。

子组件其实是父组件的一个节点。从上到下编译父组件模板时，遇到子组件节点就会实例化子组件挂载到父组件视图上后再继续编译子组件后面的父组件节点，因此父组件的mounted最后触发。

### 32：虚拟节点是何时生成的。

在beforeMount和Mounted之间。template上的变量也是在这个过程中求职的。data响应式数据也是在这个时候触发了getter并收集依赖的。

### 33：created和mounted最大的区别是什么

就是视图是否已经挂载。

### 34：Vue是如何编译template为虚拟节点的

编译模板就是通过一个combile方法把模板编译成AST虚拟语法树，最终转换为一个render函数，通过该render函数可以生成虚拟节点。（AST的关键）

### 35： 说说Vue是渐进式框架的理解

渐进式的意思大概就是可扩展的。例如，只有一个el选项也是Vue程序，10个Vue选项也是Vue程序。

可根据需求不断增加选项扩展实现更多功能，例如增加data，computed，watch等等。

由简入繁，都是通过配置的写法进行扩展，良好兼容。

React写法不是渐进式的。

### 36：vue的两个核心是什么

data数据层和view视图层。

Vue的核心体系是一套响应式的体系，数据变化响应式更新视图的体系。

### 37：Vue常见的性能优化。

### 38：vue中的v-html会导致哪些问题？

不安全，容易遭到xss攻击。

会替换掉标签内的子元素（组件）

### 39： v-model的实现原理? （双向绑定）

就是说通过给元素绑定不同事件获取视图数据并保存到Vue实例上，例如input事件。这就是通过视图改变数据。

再通过 v-bind绑定数据到value属性，这样就是通过数据更新视图。

### 40：**v-for中为什么要加key?** key为什么不能是下标

### 41：watch中的deep：true是如何实现的

### 42：AJAX请求在哪个生命周期中执行。

一般情况下都放到mounted中，保证逻辑的统一性，因为生命周期函数是同步执行的，AJAX是异性执行的。

服务端渲染不支持mounted方法时，所以在服务端渲染的情况下统一放到created中

### 43：**Vue的优势**

轻量级框架、简单易学、双向数据绑定、组件化、视图、数据和结构的分离、虚拟DOM、运行速度快

### 44：如果有10000条数据需要渲染，应该如何做优化。（重要，常问）

数据量太大，一次渲染需要的时间很久，影响用户体验。

优化思路：绝不能一次渲染。只能分次渲染。各种解决方案。

一次只渲染一部分数据，例如20条。然后通过分页按钮或者向下滚动的操作渲染新的数据。

如果是滚动渲染一部分数据，注意列表视图中上边被藏起来的部分和下边还没显示的部分都不应该渲染到视图上。

https://blog.csdn.net/qq_37818095/article/details/102954854

其他瞎掰：

1：用Object.freeze来创建data数据。可以取消双向绑定来优化渲染。

2：插件 clusterize.js

### 45：vue-router有哪两种模式，有什么区别

vue-router有 **哈希模式 **和 **历史记录** 两种模式。

**相同点：**

哈希模式通过监测url上哈希值的变化来切换对应的动态组件，以显示对应的路由视图。

历史记录模式通过HTML5新增的pushState与replaceState方法修改url，当url改变时切换到对应路由视图。

两种模式在url改变时都不会向服务器发起新的请求。

**不同点：**

哈希模式的url上有#号而历史记录没有。

哈希模式的哈希值是不作为请求后端的url部分的，例如：...com/#login 和 .../com对于服务器是同一个url。

因此在哈希值没有做到全页面覆盖的情况下，也不会出现404页面。

历史记录没有使用哈希值，因此每个历史记录的url都需要在后台有对应的url接口，否则后台返回404.

### 46：vue-router的哈希模式的原理是什么，vue如何监听哈希值变化

哈希模式通过监测url上哈希值的变化来切换对应的动态组件，根据routes选项匹配显示对应的路由视图。。

哈希模式通过原生的 "hashchange"事件来监听哈希值的变化。（历史记录模式监听 "popstate" 事件）











